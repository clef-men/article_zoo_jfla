\section{\Zoo features}
\label{sec:features}

In this section, we review the main features of \Zoo, starting with the most generic ones and then addressing those related to concurrency.

\subsection{Algebraic data types}

\Zoo is an untyped language but, to write interesting programs, it is convenient to work with abstractions like algebraic data types.
To simulate tuples, variants and records, we designed a machinery to define projections, constructors and record fields.

For example, one may define a list-like type with:

\begin{minted}{coq}
Notation "'Nil'"  := (in_type "t" 0) (in custom zoo_tag).
Notation "'Cons'" := (in_type "t" 1) (in custom zoo_tag).
\end{minted}

Given this incantation, one may directly use the tags \texttt{Nil} and \texttt{Cons} in data constructors using the corresponding \ZooLang constructs:

\begin{minted}{coq}
Definition map : val :=
  rec: "map" "fn" "t" =>
    match: "t" with
    | Nil =>
        §Nil
    | Cons "x" "t" =>
        let: "y" := "fn" "x" in
        ‘Cons( "y", "map" "fn" "t" )
    end.
\end{minted}

The meaning of this incantation is not really important, as such notations can be generated by \texttt{ocaml2zoo}.
Suffice it to say that it introduces the two tags in the \texttt{zoo\_tag} custom entry, on which the notations for data constructors rely.
The \mintinline{coq}{in_type} term is needed to distinguish the tags of distinct data types; crucially, it cannot be simplified away by \Coq, as this could lead to confusion during the reduction of expressions.

Similarly, one may define a record-like type with two mutable fields \texttt{f1} and \texttt{f2}:

\begin{minted}{coq}
Notation "'f1'" := (in_type "t" 0) (in custom zoo_field).
Notation "'f2'" := (in_type "t" 1) (in custom zoo_field).

Definition swap : val :=
  fun: "t" =>
    let: "f1" := "t".{f1} in
    "t" <-{f1} "t".{f2} ;;
    "t" <-{f2} "f1".
\end{minted}

\subsection{Mutually recursive functions}

\Zoo supports non-recursive ($\texttt{fun:}\ x_1 \dots x_n\ \texttt{=>}\ e$) and recursive ($\texttt{rec:}\ f\ x_1 \dots x_n\ \texttt{=>}\ e$) functions but only \emph{toplevel} mutually recursive functions.
Indeed, it is non-trivial to properly handle mutual recursion: when applying a mutually recursive function, a naive approach would replace the recursive functions by their respective bodies, but this typically makes the resulting expression unreadable.
To prevent it, the mutually recursive functions have to know one another so as to replace by the names instead of the bodies.
We simulate this using some boilerplate that can be generated by \texttt{ocaml2zoo}.
For instance, one may define two mutually recursive functions \texttt{f} and \texttt{g} as follows:

\begin{minted}{coq}
Definition f_g := (
  recs: "f" "x" => "g" "x"
  and:  "g" "x" => "f" "x"
)%zoo_recs.

(* boilerplate *)
Definition f := ValRecs 0 f_g.
Definition g := ValRecs 1 f_g.
Instance : AsValRecs' f 0 f_g [f;g]. Proof. done. Qed.
Instance : AsValRecs' g 1 f_g [f;g]. Proof. done. Qed.
\end{minted}

\subsection{Standard library}

To save users from reinventing the wheel, we provide a standard library---more or less a subset of the \OCaml standard library.
Currently, it mainly includes standard data structures like: array (\mintinline{ocaml}{Array}), resizable array (\mintinline{ocaml}{Dynarray}), list (\mintinline{ocaml}{List}), stack (\mintinline{ocaml}{Stack}), queue (\mintinline{ocaml}{Queue}), double-ended queue, mutex (\mintinline{ocaml}{Mutex}), condition variable (\mintinline{ocaml}{Condition}).o

Each of these standard modules contains \ZooLang functions and their verified specifications.
These specifications are modular: they can be used to verify more complex data structures.
As an evidence of this, lists~\cite{DBLP:journals/pacmpl/AllainC0S24} and arrays~\cite{allain:hal-04681703} have been successfully used in verification efforts based on \Zoo.

\subsection{Physical equality}
\label{sec:physical_equality}

In \Zoo, a value is either a bool, an integer, a memory location, a function or an immutable block.
To deal with physical equality in the semantics, we have to specify what guarantees we get when 1) physical comparison returns \mintinline{ocaml}{true} and 2) when it returns \mintinline{ocaml}{false}.

We assume that the program is semantically well typed, if not syntactically well typed, in the sense that compared values are loosely compatible: a boolean may be compared with another boolean or a location, an integer may be compared with another integer or a location, an immutable block may be compared with another immutable block or a location.
This means we never physically compare, \eg, a boolean and an integer, an integer and an immutable block.
If we wanted to allow it, we would have to extend the semantics of physical comparison to account for conflicts in the memory representation of values.

For booleans, integers and memory locations, the semantics of physical equality is plain equality.
Let us consider the case of abstract values (functions and immutable blocks).

If physical comparison returns \mintinline{ocaml}{true}, the semantics of \OCaml tells us that these values are structurally equal.
This is very weak because structural equality for memory locations is not plain equality.
In fact, assuming only that, the stack of \cref{sec:introduction} and many other concurrent algorithms relying on physical equality would be incorrect.
Indeed, for \eg a stack of references (\mintinline{ocaml}{'a ref}), a successful \mintinline{ocaml}{Atomic.compare_and_set} in \mintinline{ocaml}{push} or \mintinline{ocaml}{pop} would not be guaranteed to have seen the exact same list of references; the expected specification of \cref{sec:zoo} would not work.
What we want and what we assume in our semantics is plain equality.
Hopefully, this should be correct in practice, as we know physical equality is implemented as plain comparison.

If physical comparison returns \mintinline{ocaml}{false}, the semantics of \OCaml tells us essentially nothing: two immutable blocks may have distinct identities but same content.
However, given this semantics, we cannot verify the \mintinline{ocaml}{Rcfd} example of \cref{sec:introduction}.
To see why, consider the first \mintinline{ocaml}{Atomic.compare_and_set} in the \mintinline{ocaml}{close} function.
If it fails, we expect to see a \mintinline{ocaml}{Closing} state because we know there is only one \mintinline{ocaml}{Open} state ever created, but we cannot prove it.
To address it, we take another step back from \OCaml's semantics by introducing the \texttt{Reveal} construct.
When applied to an immutable memory block, \texttt{Reveal} yields the same block annotated with a logical identifier that can be interpreted as its abstract identity.
The meaning of this identifier is: if physical comparison of two identified blocks returns \mintinline{ocaml}{false}, the two identifiers are necessarily distinct.
The underling assumption that we make here---which is hopefully also correct in the current implementation of \OCaml---is that the compiler may introduce sharing but not unsharing.

The introduction of \texttt{Reveal} can be performed automatically by \texttt{ocaml2zoo} provided the user annotates the data constructor (\eg \mintinline{ocaml}{Open}) with the attribute \mintinline{ocaml}{[@zoo.reveal]}.
For \mintinline{ocaml}{Rcfd.make}, it generates:

\begin{minted}{coq}
Definition rcfd_make : val :=
  fun: "fd" =>
    { #0, Reveal ‘Open( "fd" ) }.
\end{minted}

Given this semantics and having revealed the \mintinline{ocaml}{Open} block, we can verify the \mintinline{ocaml}{close} function.
Indeed, if the first \mintinline{ocaml}{Atomic.compare_and_set} fails, we now know that the identifiers of the two blocks, if any, are distinct.
As there is only one \mintinline{ocaml}{Open} block whose identifier does not change, it cannot be the case that the current state is \mintinline{ocaml}{Open}, hence it is \mintinline{ocaml}{Closing} and we can conclude.

\subsection{Structural equality}

Structural equality is also supported.
More precisely, it is not part of the semantics of the language but axiomatized on top of it\footnote{We could also have implemented it in \Zoo, but that would require more low-level primitives.}.
The reason is that it is in fact difficult to specify for arbitrary values.
Indeed, we have to handle not only abstract tree-like values (booleans, integers, immutable blocks) but also pointers to memory blocks for records.
In general, we basically have to compare graphs---which implies structural comparison may diverge.

Accordingly, the specification of $v_1\ \texttt{=}\ v_2$ requires the (partial) ownership of a \emph{memory footprint} corresponding to the union of the two compared graphs, giving the right to traverse them safely.
If it terminates, the comparison decides whether the two graphs are isomorphic.
In \Iris, this gives:

\begin{minted}{coq}
Axiom structeq_spec : ∀ `{zoo_G : !ZooG Σ} {v1 v2} footprint,
  val_traversable footprint v1 →
  val_traversable footprint v2 →
  {{{ structeq_footprint footprint }}}
    v1 = v2
  {{{ b, RET #b;
    structeq_footprint footprint ∗
    ⌜ if b then val_structeq footprint v1 v2
      else val_structne footprint v1 v2 ⌝
  }}}.
\end{minted}

Obviously, this general specification is not very convenient to work with.
Fortunately, for abstract tree-like values, we get a much simpler variant:

\begin{minted}{coq}
Lemma structeq_spec_abstract `{zoo_G : !ZooG Σ} v1 v2 :
  val_is_abstract v1 →
  val_is_abstract v2 →
  {{{ True }}}
    v1 = v2
  {{{ RET #(bool_decide (v1 = v2)); True }}}
Proof.
  ...
Qed.
\end{minted}

\subsection{Concurrent primitives}
\label{sec:atomic}

\Zoo supports concurrent primitives both on atomic references (from \mintinline{ocaml}{Atomic}) and atomic record fields (from \mintinline{ocaml}{Atomic.Loc}\footnote{The \mintinline{ocaml}{Atomic.Loc} module is part of the \href{https://github.com/ocaml/ocaml/pull/13404}{PR} that implements atomic record fields.}) according to the table below.
The \OCaml expressions listed in the left-hand column translate into the \Zoo expressions in the right-hand column.
Notice that an atomic location \mintinline[escapeinside=||]{ocaml}{[%atomic.loc |$e$|.|$f$|]} (of type \mintinline{ocaml}{_ Atomic.Loc.t}) translates directly into $e \texttt{.[} f \texttt{]}$.

\begin{center}
\begin{tabular}{ll}
    \OCaml &
    \Zoo
  \\ \hline
    \mintinline[escapeinside=||]{ocaml}{Atomic.get |$e$|} &
    $\texttt{!} e$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.set |$e_1$| |$e_2$|} &
    $e_1\ \texttt{<-}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.exchange |$e_1$| |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.compare_and_set |$e_1$| |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[contents]}\ e_2\ e_3$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.fetch_and_add |$e_1$| |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.exchange [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.compare_and_set [%atomic.loc |$e_1$|.|$f$|] |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[} f \texttt{]}\ e_2\ e_3$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.fetch_and_add [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
\end{tabular}
\end{center}

One important aspect of this translation is that atomic accesses (\mintinline{ocaml}{Atomic.get} and \mintinline{ocaml}{Atomic.set}) correspond to plain loads and stores.
This is because we are working in a sequentially consistent memory model: there is no difference between atomic and non-atomic memory locations.

\subsection{Prophecy variables}
\label{sec:prophecy}

Lockfree algorithms exhibit complex behaviors.
To tackle them, \Iris provides powerful mechanisms such as \emph{prophecy variables}~\cite{DBLP:journals/pacmpl/JungLPRTDJ20}.
Essentially, prophecy variables can be used to predict the future of the program execution and reason about it.
They are key to handle \emph{future-dependent linearization points}: linearization points that may or may not occur at a given location in the code depending on a future observation.

\Zoo supports prophecy variables through the \texttt{Proph} and \texttt{Resolve} expressions---as in \HeapLang, the canonical \Iris language.
In \OCaml, these expressions correspond to \mintinline{ocaml}{Zoo.proph} and \mintinline{ocaml}{Zoo.resolve}, that are recognized by \texttt{ocaml2zoo}.
