\section{\Zoo features}
\label{sec:features}

In this section, we review the main features of \Zoo, starting with the most generic ones and then addressing those related to concurrency.

\subsection{Algebraic data types}

\Zoo is an untyped language but, to write interesting programs, it is convenient to work with abstractions like algebraic data types.
To simulate tuples, variants and records, we designed a machinery to define projections, constructors and record fields.

For example, one may define a list-like type with:

\begin{minted}{coq}
Notation "'Nil'" := (in_type "t" 0) (in custom zoo_tag).
Notation "'Cons'" := (in_type "t" 1) (in custom zoo_tag).

Definition map : val :=
  rec: "map" "fn" "t" =>
    match: "t" with
    | Nil =>
        §Nil
    | Cons "x" "t" =>
        let: "y" := "fn" "x" in
        ‘Cons( "y", "map" "fn" "t" )
    end.
\end{minted}

Similarly, one may define a record-like type with two mutable fields \texttt{f1} and \texttt{f2}:

\begin{minted}{coq}
Notation "'f1'" := (in_type "t" 0) (in custom zoo_field).
Notation "'f2'" := (in_type "t" 1) (in custom zoo_field).

Definition swap : val :=
  fun: "t" =>
    let: "f1" := "t".{f1} in
    "t" <-{f1} "t".{f2} ;;
    "t" <-{f2} "f1".
\end{minted}

\subsection{Mutually recursive functions}

\Zoo supports non-recursive ($\texttt{fun:}\ x_1 \dots x_n\ \texttt{=>}\ e$) and recursive ($\texttt{rec:}\ f\ x_1 \dots x_n\ \texttt{=>}\ e$) functions but only \emph{toplevel} mutually recursive functions.
Indeed, it is non-trivial to properly handle mutual recursion: when applying a mutually recursive function, a naive approach would replace the recursive functions by their respective bodies, but this typically makes the resulting expression unreadable.
To prevent it, the mutually recursive functions have to know one another so as to replace by the names instead of the bodies.
We simulate this using some boilerplate that can be generated by \texttt{ocaml2zoo}.
For instance, one may define two mutually recursive functions \texttt{f} and \texttt{g} as follows:

\begin{minted}{coq}
Definition f_g := (
  recs: "f" "x" => "g" "x"
  and: "g" "x" => "f" "x"
)%zoo_recs.
Definition f := ValRecs 0 f_g.
Definition g := ValRecs 1 f_g.
Instance : AsValRecs' f 0 f_g [f;g]. Proof. done. Qed.
Instance : AsValRecs' g 1 f_g [f;g]. Proof. done. Qed.
\end{minted}

\subsection{Standard library}

To save users from reinventing the wheel, we provide a standard library---more or less a subset of the \OCaml standard library.
Currently, it mainly includes standard data structures like: array (\mintinline{ocaml}{Array}), resizable array (\mintinline{ocaml}{Dynarray}), list (\mintinline{ocaml}{List}), stack (\mintinline{ocaml}{Stack}), queue (\mintinline{ocaml}{Queue}), double-ended queue, mutex (\mintinline{ocaml}{Mutex}), condition variable (\mintinline{ocaml}{Condition}).

\subsection{Physical equality}

\subsection{Structural equality}

Structural equality is also supported.
More precisely, it is not part of the semantics of the language but axiomatized on top of it\footnote{We could also have implemented it in \Zoo, but that would require more low-level primitives.}.
The reason is that it is in fact difficult to specify for arbitrary values.
Indeed, we have to handle not only abstract tree-like values (booleans, integers, immutable blocks) but also pointers to memory blocks for records.
In general, we basically have to compare graphs---which implies structural comparison may diverge.

Accordingly, the specification of $v_1\ \texttt{=}\ v_2$ requires the (partial) ownership of a \emph{memory footprint} corresponding to the union of the two compared graphs, giving the right to traverse them safely.
If it terminates, the comparison decides whether the two graphs are isomorphic.
In \Iris, this gives:

\begin{minted}{coq}
Axiom structeq_spec : ∀ `{zoo_G : !ZooG Σ} {v1 v2} footprint,
  val_traversable footprint v1 →
  val_traversable footprint v2 →
  {{{ structeq_footprint footprint }}}
    v1 = v2
  {{{ b, RET #b;
    structeq_footprint footprint ∗
    ⌜ if b then val_structeq footprint v1 v2
      else val_structne footprint v1 v2 ⌝
  }}}.
\end{minted}

Obviously, this general specification is not very convenient to work with.
Fortunately, for abstract tree-like values, we get a much simpler variant:

\begin{minted}{coq}
Lemma structeq_spec_abstract `{zoo_G : !ZooG Σ} v1 v2 :
  val_is_abstract v1 →
  val_is_abstract v2 →
  {{{ True }}}
    v1 = v2
  {{{ RET #(bool_decide (v1 = v2)); True }}}
Proof.
  ...
Qed.
\end{minted}

\subsection{Concurrent primitives}

\Zoo supports concurrent primitives both on atomic references (from \mintinline{ocaml}{Atomic}) and atomic record fields (from \mintinline{ocaml}{Atomic.Loc}\footnote{The \mintinline{ocaml}{Atomic.Loc} module is part of the \href{https://github.com/ocaml/ocaml/pull/13404}{PR} that implements atomic record fields.}) according to the table below.
The \OCaml expressions listed in the left-hand column translate into the \Zoo expressions in the right-hand column.
Notice that an atomic location \mintinline[escapeinside=||]{ocaml}{[%atomic.loc |$e$|.|$f$|]} (of type \mintinline{ocaml}{_ Atomic.Loc.t}) translates directly into $e \texttt{.[} f \texttt{]}$.

\begin{center}
\begin{tabular}{ll}
    \OCaml &
    \Zoo
  \\ \hline
    \mintinline[escapeinside=||]{ocaml}{Atomic.get |$e$|} &
    $\texttt{!} e$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.set |$e_1$| |$e_2$|} &
    $e_1\ \texttt{<-}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.exchange |$e_1$| |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.compare_and_set |$e_1$| |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[contents]}\ e_2\ e_3$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.fetch_and_add |$e_1$| |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.exchange [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.compare_and_set [%atomic.loc |$e_1$|.|$f$|] |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[} f \texttt{]}\ e_2\ e_3$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.fetch_and_add [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
\end{tabular}
\end{center}

One important aspect of this translation is that atomic accesses (\mintinline{ocaml}{Atomic.get} and \mintinline{ocaml}{Atomic.set}) correspond to plain loads and stores.
This is because we are working in a sequentially consistent memory model: there is no difference between atomic and non-atomic memory locations.

\subsection{Prophecy variables}

Lockfree algorithms exhibit complex behaviors.
To tackle them, \Iris provides powerful mechanisms such as \emph{prophecy variables}~\cite{DBLP:journals/pacmpl/JungLPRTDJ20}.
Essentially, prophecy variables can be used to predict the future of the program execution and reason about it.
They are key to handle \emph{future-dependent linearization points}: linearization points that may or may not occur at a given location in the code depending on a future observation.

\Zoo supports prophecy variables through the \texttt{Proph} and \texttt{Resolve} expressions---as in \HeapLang, the canonical \Iris language.
In \OCaml, these expressions correspond to \mintinline{ocaml}{Zoo.proph} and \mintinline{ocaml}{Zoo.resolve}, that are recognized by \texttt{ocaml2zoo}.
